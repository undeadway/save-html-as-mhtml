/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/fileinfo/index.js":
/*!****************************************!*\
  !*** ./node_modules/fileinfo/index.js ***!
  \****************************************/
/***/ ((module) => {

eval("/*\n\tfileinfo : https://github.com/mudcube/fileinfo\n*/\n\nconst DEBUG = false\n\nfunction fileinfo(input) {\n\treturn wrap((resolve, reject) => {\n\t\tif (typeof input === 'string') {\n\t\t\tconst res = fromString(input)\n\t\t\tif (res) {\n\t\t\t\tresolve(res)\n\t\t\t} else {\n\t\t\t\tresolve(byExtension.png); //- fix me\n\t\t\t\twarn(input, 1)\n\t\t\t}\n\t\t} else {\n\t\t\tif (isBlob(input)) {\n\t\t\t\tfromBlob(input, resolve, handleError)\n\t\t\t} else {\n\t\t\t\thandleError()\n\t\t\t\twarn(input, 2)\n\t\t\t}\n\t\t}\n\t\tfunction handleError() {\n\t\t\treject && reject({\n\t\t\t\tmessage: 'blobFromBuffer: format could not be determined'\n\t\t\t})\n\t\t}\n\t}, arguments)\n}\n\nfileinfo.fromBlob = fromBlob\nfileinfo.fromBuffer = fromBuffer\nfileinfo.fromString = fromString\nfileinfo.fromExtension = fromExtension\nfileinfo.fromMime = fromMime\n\nfileinfo.is = function (input, targetType, onsuccess, onerror) {\n\treturn wrap((onsuccess, onerror) => {\n\t\tfileinfo(input, fileInfo => {\n\t\t\tfor (let key in fileInfo) {\n\t\t\t\tif (targetType === fileInfo[key]) {\n\t\t\t\t\tonsuccess(true)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tonsuccess(false)\n\t\t}, onerror)\n\t}, arguments)\n}\n\nfileinfo.isBlob = isBlob\nfileinfo.isFile = isFile\nfileinfo.isSVGString = isSVGString\n\n// References:\n// http://en.wikipedia.org/wiki/List_of_file_bySignature\n// http://www.filebySignature.net/\n\nconst bySignature = {\n\t/* image */\n\t'424d': 'bmp',\n\t'47494638': 'gif', // 47 49 46 38 37 61 (GIF87a) or 47 49 46 38 39 61 (GIF89a)\n\t'69636e73': 'icns', // http://en.wikipedia.org/wiki/Apple_Icon_Image_format\n\t'00000100': 'ico',\n\t'ffd8ff': 'jpg',\n\t'89504e47': 'png', // 89 50 4E 47 0D 0A 1A 0A\n\t'4d4d002a': 'tiff', // big endian format\n\t'49492a00': 'tiff', // little endian format\n\t'57454250': 'webp',\n\n\t/* audio */\n\t'464f524d': 'aiff', // 46 4F 52 4D nn nn nn nn 41 49 46 46\n\t'4d546864': 'mid', // 'MThd'\n\t'fffb': 'mp3',\n\t'494433': 'mp3',\n\t'4f676753': 'ogg',\n\t'52494646': 'wav', // 52 49 46 46 nn nn nn nn 57 41 56 45\n\n\t/* video */\n\t'000001b3': 'mpeg', // elementary stream (ES) // http://en.wikipedia.org/wiki/Elementary_stream\n\t'000001ba': 'mpeg', // program stream (PS) // http://en.wikipedia.org/wiki/MPEG_program_stream\n\t'1a45dfa3': 'webm',\n\n\t/* font */\n\t'4c50': 'eot',\n\t'00010000': 'ttf', // windows - 00 01 00 00 00\n\t'74727565': 'ttf', // mac\n\t'4f54544f': 'otf', // 4F 54 54 4F 00\n\t'774f4646': 'woff', // 77 4F 46 46 00 01 00 00\n\t'774f4632': 'woff2', // 77 4F 46 32 00 01 00 00\n\n\t/* package */\n\t'25504446': 'pdf', // '%PDF'\n\t'25215053': 'ps',  // '%!PS-Ado'\n\t'38425053': 'psd', // '8BPS'\n\t'7b5c7274': 'rtf', // '{\\rtf1' - 7b 5c 72 74 66 31\n\t'504b0304': 'zip', // 'PK..' - archive\n\t'504b0506': 'zip', // 'PK..' - empty archive\n\t'504b0708': 'zip', // 'PK..' - spanned archive\n\n\t/* loose detection - keep at end of object */\n\t'7b': 'json' // '{'\n}\n\nconst byExtension = (function () {\n\tconst res = {\n\t\t/* text */\n\t\tjson: {\n\t\t\tmime: 'application/json',\n\t\t\ttype: 'text'\n\t\t},\n\t\ttxt: {\n\t\t\tmime: 'text/plain',\n\t\t\ttype: 'text'\n\t\t},\n\n\t\t/* image */\n\t\tbmp: {\n\t\t\tmime: 'image/bmp',\n\t\t\ttype: 'image'\n\t\t},\n\t\tgif: {\n\t\t\tmime: 'image/gif',\n\t\t\ttype: 'image'\n\t\t},\n\t\ticns: {\n\t\t\tmime: 'image/icns',\n\t\t\ttype: 'image'\n\t\t},\n\t\tico: {\n\t\t\tmime: 'image/x-icon',\n\t\t\ttype: 'image'\n\t\t},\n\t\tjpeg: {\n\t\t\tmime: 'image/jpg',\n\t\t\ttype: 'image'\n\t\t},\n\t\tjpg: {\n\t\t\tmime: 'image/jpg',\n\t\t\ttype: 'image'\n\t\t},\n\t\tpng: {\n\t\t\tmime: 'image/png',\n\t\t\ttype: 'image'\n\t\t},\n\t\ttiff: {\n\t\t\tmime: 'image/tiff',\n\t\t\ttype: 'image'\n\t\t},\n\t\twebp: {\n\t\t\tmime: 'image/webp',\n\t\t\ttype: 'image'\n\t\t},\n\n\t\t/* audio */\n\t\taiff: {\n\t\t\tmime: 'audio/aiff',\n\t\t\ttype: 'audio'\n\t\t},\n\t\tmid: {\n\t\t\tmime: 'audio/mid',\n\t\t\ttype: 'audio'\n\t\t},\n\t\tmp3: {\n\t\t\tmime: 'audio/mpeg',\n\t\t\ttype: 'audio'\n\t\t},\n\t\togg: {\n\t\t\tmime: 'audio/ogg',\n\t\t\ttype: 'audio'\n\t\t},\n\t\twav: {\n\t\t\tmime: 'audio/wav',\n\t\t\ttype: 'audio'\n\t\t},\n\n\t\t/* video */\n\t\tmp4: {\n\t\t\tmime: 'video/mp4',\n\t\t\ttype: 'video'\n\t\t},\n\t\tmpeg: {\n\t\t\tmime: 'video/mpeg',\n\t\t\ttype: 'video'\n\t\t},\n\t\twebm: {\n\t\t\tmime: 'video/webm',\n\t\t\ttype: 'video'\n\t\t},\n\n\t\t/* clipart */\n\t\tsvg: {\n\t\t\tmime: 'image/svg+xml',\n\t\t\ttype: 'clipart'\n\t\t},\n\n\t\t/* font */\n\t\teot: { // http://en.wikipedia.org/wiki/Embedded_OpenType\n\t\t\tmime: 'application/vnd.ms-fontobject',\n\t\t\ttype: 'font'\n\t\t},\n\t\totf: {\n\t\t\tmime: 'application/font-sfnt',\n\t\t\ttype: 'font'\n\t\t},\n\t\tttf: {\n\t\t\tmime: 'application/font-sfnt',\n\t\t\ttype: 'font'\n\t\t},\n\t\twoff: {\n\t\t\tmime: 'application/font-woff',\n\t\t\ttype: 'font'\n\t\t},\n\t\twoff2: {\n\t\t\tmime: 'application/font-woff',\n\t\t\ttype: 'font'\n\t\t},\n\n\t\t/* package */\n\t\tpdf: {\n\t\t\tmime: 'application/pdf',\n\t\t\ttype: 'package'\n\t\t},\n\t\tps: {\n\t\t\tmime: 'application/postscript',\n\t\t\ttype: 'package'\n\t\t},\n\t\tpsd: {\n\t\t\tmime: 'image/vnd.adobe.photoshop',\n\t\t\ttype: 'package'\n\t\t},\n\t\trtf: {\n\t\t\tmime: 'application/rtf',\n\t\t\ttype: 'package'\n\t\t},\n\t\tzip: {\n\t\t\tmime: 'application/zip',\n\t\t\ttype: 'package'\n\t\t}\n\t}\n\tfor (let ext in res) {\n\t\tres[ext].extension = ext\n\t}\n\treturn res\n})()\n\nconst byMime = (function () {\n\tconst res = {}\n\tfor (let ext in byExtension) {\n\t\tconst item = byExtension[ext]\n\t\tres[item.mime] = item\n\t}\n\treturn res\n})()\n\nfunction wrap(fn, options) {\n\tif (typeof options[1] === 'function') {\n\t\tfn(options[1], options[2], options[3])\n\t} else {\n\t\treturn new Promise(fn)\n\t}\n}\n\n/* log */\nfunction warn(input, idx) {\n\tDEBUG && console.warn('could not detect format', input, idx)\n}\n\n/* detect */\nfunction isBlob(input) {\n\tconst type = Object.prototype.toString.call(input)\n\treturn type === '[object Blob]' || type === '[object File]'\n}\n\nfunction isFile(input) {\n\tconst type = Object.prototype.toString.call(input)\n\treturn type === '[object File]'\n}\n\nfunction isSVGString(input) { // via vector.SVG.detect\n\treturn input.startsWith('data:image/svg') ||\n\t\tinput.startsWith('<?xml') && input.includes('<svg') ||\n\t\tinput.startsWith('<svg')\n}\n\n/* detect via Blob */\nfunction fromBlob(blob, onsuccess, onerror) {\n\tconst length = Math.min(5, blob.size)\n\tconst slice = blob.slice(0, length)\n\tconst reader = new FileReader()\n\treader.onload = function (event) {\n\t\tconst buffer = reader.result\n\t\tconst res = fromBuffer(buffer) || byMime[blob.type]\n\t\tif (res) {\n\t\t\tonsuccess(res)\n\t\t} else {\n\t\t\tonerror && onerror()\n\t\t\twarn(blob, 3)\n\t\t}\n\t}\n\treader.readAsArrayBuffer(slice)\n}\n\n/* detect via ArrayBuffer */\nfunction fromBuffer(buffer) {\n\tif (buffer.byteLength > 4) {\n\t\tbuffer = buffer.slice(0, 5)\n\t}\n\n\tconst signature = bufferToHex(buffer)\n\tfor (let sig in bySignature) {\n\t\tif (sig === signature.slice(0, sig.length)) {\n\t\t\tconst ext = bySignature[sig]\n\t\t\treturn byExtension[ext]\n\t\t}\n\t}\n}\n\nfunction bufferToHex(buffer) {\n\tconst array = new Uint8Array(buffer)\n\tlet hex = ''\n\tfor (let i = 0; i < array.length; i++) {\n\t\tconst code = array[i].toString(16)\n\t\tif (code.length === 1) {\n\t\t\thex += '0' + code\n\t\t} else {\n\t\t\thex += code\n\t\t}\n\t}\n\treturn hex\n}\n\n/* detect via String */\nfunction fromString(string) {\n\tconst lower = string.toLowerCase()\n\tif (string.startsWith('data:')) {\n\t\tconst mime = lower.substr(5).split(';').shift()\n\t\treturn byMime[mime]\n\t}\n\n\tconst ext = lower.split('.').pop()\n\tif (byExtension[ext]) {\n\t\treturn byExtension[ext]\n\t} else {\n\t\tif (isSVGString(string)) {\n\t\t\treturn byExtension.svg\n\t\t}\n\t}\n}\n\nfunction fromExtension(ext) {\n\treturn byExtension[ext]\n}\n\nfunction fromMime(mime) {\n\treturn byMime[mime]\n}\n\nmodule.exports = fileinfo\n\n//# sourceURL=webpack://save-html-as-mhtml/./node_modules/fileinfo/index.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((module, exports, __webpack_require__) => {

eval("const utils = __webpack_require__(/*! ./lib/utils */ \"./src/lib/utils.js\");\r\nconst Client = utils.isBbrowser() ? __webpack_require__(/*! ./modules/browser */ \"./src/modules/browser.js\") : __webpack_require__(/*! ./modules/others */ \"./src/modules/others.js\");\r\n\r\nconst { UPPER_CASE, LOWER_CASE, DIGIT, BLANK, MIME_TEXT_CSS, MIME_TEXT_HTML, QUOTED_PRINTABLE, AT_MHTML_BLINK } = __webpack_require__(/*! ./lib/constants */ \"./src/lib/constants.js\");\r\nconst LETTERS = `${UPPER_CASE}${LOWER_CASE}`, UPPER_DIGIT = `${UPPER_CASE}${DIGIT}`, LETTER_DIGIT = `${LETTERS}${DIGIT}`;\r\n\r\nconst execute = async (html, options = {}) => {\r\n\t// 初始化\r\n\tconst contentLocation = options.contentLocation || \"http://localhost/\";\r\n\tlet input = urlEncode(html).replaceAll(\"=\\\"\", \"=3D\\\"\");\r\n\tconst boundary = `----MultipartBoundary--${createBoundary()}----`;\r\n\tlet contentId = Date.now().toString(16).toUpperCase() + Math.random().toString(16).slice(2).toUpperCase();\r\n\tfor (let i = contentId.length; i < 32; i++) {\r\n\t\tconst ch = UPPER_DIGIT[Math.floor(Math.random() * 36)];\r\n\t\tcontentId += ch;\r\n\t}\r\n\r\n\tconst styles = Client.getStyles(options); \t// CSS\r\n\r\n\tconst contents = [`<!DOCTYPE html><html lang=3D\\\"zh-CN\\\" class=3D\\\" \\\"><head><meta http-equiv=3D\\\"Content-Type\\\" content=3D\\\"${MIME_TEXT_HTML}; charset=3DUTF-8\\\">`];\r\n\tfor (const style of styles) {\r\n\t\tcontents.push(`<link rel=3D\"stylesheet\" type=3D\"${MIME_TEXT_CSS}\" href=3D\"${style.contentLocation}\" />`);\r\n\t}\r\n\tcontents.push(`<body>${input}</body></html>`);\r\n\r\n\tconst output = [\r\n\t\t\"From: <Saved by Blink>\",\r\n\t\t`Snapshot-Content-Location:${contentLocation}`,\r\n\t\t`Subject: =?utf-8?Q?${urlEncode(options.fileName)}?=`,\r\n\t\tutils.getFormattedDate(),\r\n\t\t\"MIME-Version: 1.0\",\r\n\t\t\"Content-Type: multipart/related;\",\r\n\t\t`\ttype=\"${MIME_TEXT_HTML}\";`,\r\n\t\t` boundary=${boundary}`,\r\n\t\tBLANK, BLANK, // 两个空行\r\n\t\t// 文本内容部分\r\n\t\t`--${boundary}`,\r\n\t\t`Content-Type: ${MIME_TEXT_HTML}`,\r\n\t\t`Content-ID: <frame-${contentId}${AT_MHTML_BLINK}>`,\r\n\t\t`Content-Transfer-Encoding: ${QUOTED_PRINTABLE}`,\r\n\t\t`Content-Location:${contentLocation}`,\r\n\t\tBLANK,\r\n\t\tcontents.join(BLANK),\r\n\t\tBLANK\r\n\t];\r\n\r\n\tfor (const style of styles) {\r\n\t\tif (!style.value) continue;\r\n\t\tcreateExtern(output, boundary, style);\r\n\t}\r\n\r\n\tconst files = await Client.getFilesBase64(html, contentLocation); // 图片\r\n\r\n\tfor (const file of files) {\r\n\t\tif (!file.value) continue;\r\n\t\tcreateExtern(output, boundary, file);\r\n\t}\r\n\r\n\toutput.push(`--${boundary}--`);\r\n\r\n\tClient.write(output.join(\"\\r\\n\"), options);\r\n}\r\n\r\nfunction createExtern (output, boundary, { contentType, contentTransferEncoding, contentLocation, value }) {\r\n\toutput.push(`--${boundary}`);\r\n\toutput.push(`Content-Type: ${contentType}`);\r\n\toutput.push(`Content-Transfer-Encoding: ${contentTransferEncoding}`);\r\n\toutput.push(`Content-Location: ${contentLocation}`);\r\n\toutput.push(BLANK);\r\n\toutput.push(value);\r\n\toutput.push(BLANK);\r\n}\r\n\r\nfunction urlEncode (input) {\r\n\tconst output = [];\r\n\tfor (let i = 0, len = input.length; i < len; i++) {\r\n\t\tlet ch = input[i];\r\n\t\tconst chCode = ch.charCodeAt(0);\r\n\t\t// 这里的用法来自 nodejs 的 _http_common.js 的 303-326 行（可能会随着版本不同，写法、位置都有所变化）\r\n\t\t// 调用函数是 ：checkInvalidHeaderChar\r\n\t\tif (((chCode <= 31 && chCode !== 9) || chCode > 255 || chCode === 127)) {\r\n\t\t\tch = encodeURIComponent(ch);\r\n\t\t\tch = ch.replaceAll(\"%\", \"=\");\r\n\t\t\toutput.push(ch);\r\n\t\t} else {\r\n\t\t\toutput.push(ch);\r\n\t\t}\r\n\t}\r\n\r\n\treturn output.join(BLANK);\r\n}\r\n\r\nfunction createBoundary () {\r\n\t// 第一位字母\r\n\tconst output = [ LETTERS[Math.floor(Math.random() * 52)]] ;\r\n\r\n\t// 后面是字母+数字，合计 43 位\r\n\tfor (let i = 0; i < 42; i++) {\r\n\t\tconst ch = LETTER_DIGIT[Math.floor(Math.random() * 62)];\r\n\t\toutput.push(ch);\r\n\t}\r\n\r\n\treturn output.join(BLANK);\r\n}\r\n\r\nmodule.exports = exports = execute;\r\n\n\n//# sourceURL=webpack://save-html-as-mhtml/./src/index.js?");

/***/ }),

/***/ "./src/lib/constants.js":
/*!******************************!*\
  !*** ./src/lib/constants.js ***!
  \******************************/
/***/ ((module, exports) => {

eval("const BASE64 = \"base64\";\r\nconst BINARY = \"binary\";\r\nconst UPPER_CASE = \"ABCDEFGHIJKLIMOPQRSTUVWXYZ\";\r\nconst LOWER_CASE = \"abcdefghijklmnopqrstuvwxyz\";\r\nconst DIGIT = \"1234567890\";\r\n\r\nconst MIME_TEXT_CSS = \"text/css\", MIME_TEXT_HTML = \"text/html\";\r\nconst QUOTED_PRINTABLE = \"quoted-printable\";\r\nconst AT_MHTML_BLINK = \"@mhtml.blink\";\r\n\r\nconst WINDOWS_PATH_REGX = /^[a-zA-Z]:/;\r\nconst HTML_IMAGE_REGX = /<img.*?src=[\\\"|\\']?(.*?)[\\\"|\\']?\\s.*?>/i;\r\n\r\nconst HTTP = \"http\", HTTPS = \"https\";\r\nconst MK_POINT = \".\", MK_DASH = \"-\", MK_SLASH = \"/\";\r\nconst BLANK = \"\";\r\n\r\n\r\nmodule.exports = exports = {\r\n    BASE64,\r\n    BINARY,\r\n    UPPER_CASE,\r\n    LOWER_CASE,\r\n    DIGIT,\r\n    WINDOWS_PATH_REGX,\r\n    HTML_IMAGE_REGX,\r\n    HTTP,\r\n    HTTPS,\r\n    MIME_TEXT_CSS,\r\n    MIME_TEXT_HTML,\r\n    QUOTED_PRINTABLE,\r\n    AT_MHTML_BLINK,\r\n    MK_DASH,\r\n    MK_POINT,\r\n    MK_SLASH,\r\n    BLANK,\r\n};\r\n\n\n//# sourceURL=webpack://save-html-as-mhtml/./src/lib/constants.js?");

/***/ }),

/***/ "./src/lib/utils.js":
/*!**************************!*\
  !*** ./src/lib/utils.js ***!
  \**************************/
/***/ ((module, exports) => {

eval("const side = typeof (window) !== \"undefined\"; // 设置端点，side = true 浏览器环境 side = false 非浏览器环境\r\nconst isBbrowser = () => {\r\n\treturn side;\r\n}\r\n\r\nconst checkNumberIsNotEmpty = (input) => {\r\n\tif (checkObjectIsNotEmpty(input)) {\r\n\t\treturn !isNaN(input);\r\n\t} else {\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nconst checkObjectIsNotEmpty = (input) => {\r\n\t// 先去除掉 null、undefined、[]、\"\"\r\n\tif (input === null || input === undefined) {\r\n\t\treturn false;\r\n\t} else if (Array.isArray(input)) {\r\n\t\treturn input.length > 0;\r\n\t} else if ( typeof(input) === \"string\") {\r\n\t\treturn input.length > 0;\r\n\t} else if (typeof(input) === \"object\") {\r\n\t\tconst keys = Object.keys(input);\r\n\t\treturn keys.length > 0;\r\n\t} else {\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\nconst WEEK_DAYS = [ \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\" ];\r\nconst MONTH_LIST = [ \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" ];\r\n\r\nconst getFormattedDate = () => {\r\n\tconst dt = new Date();\r\n\tconst day = dt.getDay();\r\n\tconst month = dt.getMonth();\r\n\tconst year = dt.getFullYear();\r\n\tlet date = dt.getDate();\r\n\tif (date < 10) {\r\n\t\tdate = `0${date}`;\r\n\t}\r\n\tlet hours = dt.getHours();\r\n\tif (hours < 10) {\r\n\t\thours = `0${hours}`;\r\n\t}\r\n\tlet miinutes = dt.getMinutes();\r\n\tif (miinutes < 10) {\r\n\t\tmiinutes = `0${miinutes}`;\r\n\t}\r\n\tlet seconds = dt.getSeconds();\r\n\tif (seconds < 10) {\r\n\t\tseconds = `0${seconds}`;\r\n\t}\r\n\r\n\tconst output = `Date: ${WEEK_DAYS[day]}, ${date} ${MONTH_LIST[month]} ${year} ${hours}:${miinutes}:${seconds} +0800`;\r\n\treturn output;\r\n}\r\n\r\nmodule.exports = exports = {\r\n\tcheckNumberIsNotEmpty,\r\n\tcheckObjectIsNotEmpty,\r\n\tisBbrowser,\r\n\tgetFormattedDate\r\n};\r\n\n\n//# sourceURL=webpack://save-html-as-mhtml/./src/lib/utils.js?");

/***/ }),

/***/ "./src/modules/browser.js":
/*!********************************!*\
  !*** ./src/modules/browser.js ***!
  \********************************/
/***/ ((module, exports, __webpack_require__) => {

eval("const utils = __webpack_require__(/*! ./../lib/utils */ \"./src/lib/utils.js\");\r\nconst { MIME_TEXT_CSS, QUOTED_PRINTABLE, HTML_IMAGE_REGX, MK_DASH, MK_POINT, BLANK, AT_MHTML_BLINK } = __webpack_require__(/*! ./../lib/constants */ \"./src/lib/constants.js\");\r\n\r\nconst getStyles = (options) => {\r\n\tconst styles = document.getElementsByTagName(\"style\");\r\n\tconst symbol = options.style.symbol || BLANK;\r\n\tconst output = [];\r\n\r\n\tfor (const { innerText } of styles) {\r\n\t\ttry {\r\n\t\t\t// 这里是希望不载入太多的 css 属性，所以设置了 symbol 作为是否含有该字符串的判断\r\n\t\t\t// 比如如果使用了某些库，则可以使用 symbol \r\n\t\t\tif (utils.checkObjectIsNotEmpty(innerText) && innerText.indexOf(symbol) >= 0) {\r\n\t\t\t\tlet random = (Math.random()).toString();\r\n\t\t\t\trandom = random.replace(MK_POINT, MK_DASH);\r\n\r\n\t\t\t\toutput.push({\r\n\t\t\t\t\tcontentType: MIME_TEXT_CSS,\r\n\t\t\t\t\tcontentTransferEncoding: QUOTED_PRINTABLE,\r\n\t\t\t\t\tcontentLocation: `cid:css-${Date.now()}-${random}${AT_MHTML_BLINK}`,\r\n\t\t\t\t\tvalue: innerText\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}catch (err) {\r\n\t\t\tconsole.log(err);\r\n\t\t}\r\n\t}\r\n\r\n\treturn output;\r\n}\r\n\r\nconst getFilesBase64 = async (html) => {\r\n\tconst arr = [];\r\n\r\n\twhile ((matched = html.match(HTML_IMAGE_REGX)) !== null) {\r\n\t\tlet [ proto, src ] = matched;\r\n\r\n\t\t/**\r\n\t\t * http(s)://abac.com/a.jpg 不处理\r\n\t\t * //abac.com/a.jpg => 不处理\r\n\t\t * abac.com/a.jpg 不处理\r\n\t\t * /abc/a.jpg => 当前网网站的地址（http://abc.com） + /abc/a.jpg\r\n\t\t * ../abc/a.jpg => 当前网页的路径（http://abc.com/a/b/） + ../abc/a.jpg\r\n\t\t */\r\n\t\tif (src.indexOf(\"/\") === 0 && src.indexOf(\"//\") !== 0) {\r\n\t\t\tsrc = document.location.origin + src;\r\n\t\t}\r\n\t\tif (src.indexOf(\".\") === 0) {\r\n\t\t\tsrc = document.location.href + src;\r\n\t\t}\r\n\r\n\t\tconst promise = new Promise((resolve, reject) => {\r\n\t\t\tfetch(src).then(async response => {\r\n\t\t\t\tif (response.ok) {\r\n\t\t\t\t\tconst blob = await response.blob();\r\n\t\t\t\t\tconst reader = new FileReader();\r\n\t\t\t\t\treader.readAsDataURL(blob);\r\n\t\t\t\t\treader.onload = function (e) {\r\n\t\t\t\t\t\t// data:image/png;base64,iVBORw0KGgo...\r\n\t\t\t\t\t\tconst { result } = e.target;\r\n\t\t\t\t\t\tconst first = result.slice(5, 21).split(\";\");\r\n\t\t\t\t\t\tconst base64Val = result.slice(22);\r\n\t\t\t\t\t\tresolve({contentLocation: src, value: base64Val, contentType: first[0], contentTransferEncoding: first[1]});\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresolve({}); // 如果获取文件失败,则返回一个空对象，至少让程序不中途崩溃\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\tarr.push(promise);\r\n\t\thtml = html.replace(matched[0], BLANK);\r\n\t}\r\n\r\n\tconst output = await Promise.all(arr);\r\n\treturn output;\r\n}\r\n\r\nconst write = (output, { fileName }) => {\r\n\tconst urlObject = window.URL || window.webkitURL || window;\r\n\tconst myFile = new Blob([output]);\r\n\tvar saveLink = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"a\");\r\n\tsaveLink.href = urlObject.createObjectURL(myFile);\r\n\tsaveLink.download = `${fileName}.mhtml`;\r\n\r\n\tconst ev = document.createEvent(\"MouseEvents\");\r\n\tev.initMouseEvent(\"click\", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\r\n\tsaveLink.dispatchEvent(ev);\r\n}\r\n\r\nmodule.exports = exports = {\r\n\tgetStyles,\r\n\tgetFilesBase64,\r\n\twrite\r\n}\r\n\n\n//# sourceURL=webpack://save-html-as-mhtml/./src/modules/browser.js?");

/***/ }),

/***/ "./src/modules/others.js":
/*!*******************************!*\
  !*** ./src/modules/others.js ***!
  \*******************************/
/***/ ((module, exports, __webpack_require__) => {

eval("const fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\r\nconst http = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'http'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\r\nconst https = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'https'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\r\nconst fileinfo = __webpack_require__(/*! fileinfo */ \"./node_modules/fileinfo/index.js\");\r\nconst { BASE64, BINARY, HTTP, HTTPS, WINDOWS_PATH_REGX, HTML_IMAGE_REGX, MIME_TEXT_CSS,\r\n\t\tMK_DASH, MK_POINT, MK_SLASH, BLANK, QUOTED_PRINTABLE, AT_MHTML_BLINK } = __webpack_require__(/*! ./../lib/constants */ \"./src/lib/constants.js\");\r\n\r\nconst getStyles = (options) => {\r\n\r\n\tconst output = [];\r\n\ttry {\r\n\t\tconst paths = Array.isArray(options.style.filePath) ? options.style.filePath : [ options.style.filePath ];\r\n\t\tfor (const filePath of paths) {\r\n\t\t\tconst data = fs.readFileSync(filePath);\r\n\r\n\t\t\tlet random = (Math.random()).toString();\r\n\t\t\trandom = random.replace(MK_POINT, MK_DASH);\r\n\t\t\toutput.push({\r\n\t\t\t\tcontentType: MIME_TEXT_CSS,\r\n\t\t\t\tcontentTransferEncoding: QUOTED_PRINTABLE,\r\n\t\t\t\tcontentLocation: `cid:css-${Date.now()}-${random}${AT_MHTML_BLINK}`,\r\n\t\t\t\tvalue: data\r\n\t\t\t});\r\n\t\t}\r\n\t} catch {\r\n\t\t// 这里是为了保证文件读取失败不要造成崩溃\r\n\t} finally {\r\n\t\treturn output;\r\n\t}\r\n}\r\n\r\nconst getFilesBase64 = async (html, contentLocation) => {\r\n\tconst arr = [];\r\n\r\n\twhile ((matched = html.match(HTML_IMAGE_REGX)) !== null) {\r\n\t\tlet [ proto, path ] = matched;\r\n\r\n\t\tconst promise = new Promise((resolve, reject) => {\r\n\t\t\tlet fileName = path.split(MK_SLASH);\r\n\t\t\tfileName = fileName[fileName.length - 1];\r\n\t\t\tif (path.indexOf(HTTP) === 0) { // 非浏览器环境下，图片地址如果以 http 开头，则认为是网络图片，\r\n\t\t\t\tconst server = path.indexOf(HTTPS) === 0 ? https : http; // TODO 请求 https 现在会出错，原因还要调查\r\n\t\t\t\t\r\n\t\t\t\tserver.get(path, (response) => {\r\n\r\n\t\t\t\t\tconst { statusCode } = response;\r\n\t\t\t\t\t// const contentType = response.headers['content-type']; // TODO 这里不知道是否还有用，暂时留着\r\n\r\n\t\t\t\t\t// 任何 2xx 状态码都表示成功响应，但这里只检查 200。\r\n\t\t\t\t\tif (statusCode !== 200) {\r\n\t\t\t\t\t\t// 消费响应数据以释放内存\r\n\t\t\t\t\t\tresponse.resume();\r\n\t\t\t\t\t\tresolve({}); // 如果获取文件失败,则返回一个空对象，至少让程序不中途崩溃\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet data = BLANK;\r\n\t\t\t\t\tresponse.setEncoding(BINARY);\r\n\t\t\t\t\tresponse.on('data', function (chunk) {\r\n\t\t\t\t\t\tdata += chunk;\r\n\t\t\t\t\t});\r\n\t\t\t\t\tresponse.on(\"end\", function () {\r\n\t\t\t\t\t\tdata = Buffer.from(data, BINARY);\r\n\t\t\t\t\t\tconst contentType = getContentTypeFromBuffer(data);\r\n\t\t\t\t\t\tdata = data.toString(BASE64);\r\n\r\n\t\t\t\t\t\tresolve({contentLocation: path, value: data, contentType, contentTransferEncoding: BASE64});\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t} else { // 不然一律以本地图片处理，而本地图片不管是否真是本地图片则不做考虑\r\n \t\t\t\t// / 开头，linux 绝对路径文件\r\n\t\t\t\t// 字母:\\ 开头，windows 绝对路径文件\r\n\t\t\t\t// 其他 相对路径文件\r\n\t\t\t\t// TODO 因为 windows 的文件路径处理起来相当麻烦，所以暂时不对 windows 的文件路径进行处理\r\n\t\t\t\t// 或者说暂时只能处理 相对路径和网络路径\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet tmpPath = path;\r\n\t\t\t\t\tif (path.indexOf(MK_SLASH) !== 0 && path.match(WINDOWS_PATH_REGX) === null) {\r\n\t\t\t\t\t\t// 如果是绝对路径，则不做任何处理，只处理相对路径\r\n\t\t\t\t\t\ttmpPath =  process.cwd() + MK_SLASH + path;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet data = fs.readFileSync(tmpPath, BINARY);\r\n\t\t\t\t\tdata = Buffer.from(data, BINARY);\r\n\t\t\t\t\tconst contentType = getContentTypeFromBuffer(data);\r\n\t\t\t\t\tdata = data.toString(BASE64);\r\n\r\n\t\t\t\t\tlet ext = fileName.split(MK_POINT);\r\n\t\t\t\t\text = ext[ext.length - 1];\r\n\r\n\t\t\t\t\t// TODO 不知道为什么，本地文件需要前面加一个 localhost 的前缀\r\n\t\t\t\t\tresolve({contentLocation: `${contentLocation}${path}`, value: data, contentType, contentTransferEncoding: BASE64});\r\n\t\t\t\t} catch (err) { // 此处包含文件获取失败\r\n\t\t\t\t\tresolve({}); // 如果获取文件失败,则返回一个空对象，至少让程序不中途崩溃\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tarr.push(promise);\r\n\t\thtml = html.replace(matched[0], BLANK);\r\n\t}\r\n\r\n\tconst output = await Promise.all(arr);\r\n\treturn output;\r\n}\r\n\r\nfunction getContentTypeFromBuffer (buffer) {\r\n\tconst res = fileinfo.fromBuffer(buffer);\r\n\treturn res.mime;\r\n}\r\n\r\nconst write = (output, { fileName, outputDir }) => {;\r\n\tfs.writeFileSync(`${outputDir}/${fileName}.mhtml`, output);\r\n}\r\n\r\nmodule.exports = exports = {\r\n\tgetStyles,\r\n\tgetFilesBase64,\r\n\twrite\r\n}\r\n\n\n//# sourceURL=webpack://save-html-as-mhtml/./src/modules/others.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;